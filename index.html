<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <!--adding the SweetAlert CDN for displaying a SweetAlert dialog box -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
</head>

<body>
    <style>
        body
        {   background-color: rgb(170, 140, 198);
            background-repeat: no-repeat;
            background-size: cover;
        }
        #score{
            display: inline-block;
        }
        div{
            font-size: 25px;
            font-weight: bold;
            font-family: monospace;
            text-align: center;
        }
        canvas{
            display: block;
            margin:0 auto;
        }
    </style>

    <div>
        <h1>Tetris Game</h1>
        <button id="start-pause">Start/Pause</button>
        <canvas id="tetris" width="200" height="400"></canvas>
        <div>
            Score : <div id="score">0</div>
        </div>

        <div>
            <button id="move-left">Left</button>
            <button id="move-right">Right</button>
            <button id="rotate">Rotate</button>
            <button id="move-down">Down</button>
        </div>

        <script>
            /*creating the I Tetris shape which is a straight line.
            It occupies a 4x1(4 squares long and 1 square wide) or
            1x4(1 square wide and 4 squares tall) in the game grid
            since it can be oriented horizontally and vertically.
            It has 4 outer arrays and each of them has 4 inner arrays */
            const I = [
            [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
            ],
            [
                [0, 0, 1, 0],
                [0, 0, 1, 0],
                [0, 0, 1, 0],
                [0, 0, 1, 0],
            ],
            [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
            ],
            [
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0],
            ]
            ];

            const J = [//creating the J Tetris shape
                [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                [
                    [0, 1, 1],
                    [0, 1, 0],
                    [0, 1, 0]
                ],
                [
                    [0, 0, 0],
                    [1, 1, 1],
                    [0, 0, 1]
                ],
                [
                    [0, 1, 0],
                    [0, 1, 0],
                    [1, 1, 0]
                ]
            ];

            const L = [//creating the L Tetris shape
                [/*first outer array which has 3 inner arrays.The 1's denotes a block
                of the L shape and 0's denotes an empty space.*/
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                [
                    [0, 1, 0],
                    [0, 1, 0],
                    [0, 1, 1]
                ],
                [
                    [0, 0, 0],
                    [1, 1, 1],
                    [1, 0, 0]
                ],
                [
                    [1, 1, 0],
                    [0, 1, 0],
                    [0, 1, 0]
                ]
            ];

            const O = [//creating the O Tetris shape.
                [//the O shape is symmetrical so one outer array is required.
                    [0, 0, 0, 0],
                    [0, 1, 1, 0],
                    [0, 1, 1, 0],
                    [0, 0, 0, 0],
                ]
            ];

            const S = [//creating the S Tetris shape. It has 4 outer arrays
                [       /*First rotation of the S Tetris shape. It has 3 inner arrays,
                        forming a 3x3 grid for the rotation*/
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                [// Second rotation of the S Tetris shape
                    [0, 1, 0],
                    [0, 1, 1],
                    [0, 0, 1]
                ],
                [// Third rotation of the S Tetris shape
                    [0, 0, 0],
                    [0, 1, 1],
                    [1, 1, 0]
                ],
                [// Fourth rotation of the S Tetris shape
                    [1, 0, 0],
                    [1, 1, 0],
                    [0, 1, 0]
                ]
            ];

            const T = [//creating the T Tetris shape
                [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                [
                    [0, 1, 0],
                    [0, 1, 1],
                    [0, 1, 0]
                ],
                [
                    [0, 0, 0],
                    [1, 1, 1],
                    [0, 1, 0]
                ],
                [
                    [0, 1, 0],
                    [1, 1, 0],
                    [0, 1, 0]
                ]
            ];

            const Z = [//creating the Z Tetris shape
                [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                [
                    [0, 0, 1],
                    [0, 1, 1],
                    [0, 1, 0]
                ],
                [
                    [0, 0, 0],
                    [1, 1, 0],
                    [0, 1, 1]
                ],
                [
                    [0, 1, 0],
                    [1, 1, 0],
                    [1, 0, 0]
                ]
            ];

            const cvs = document.getElementById("tetris");
            const ctx = cvs.getContext("2d");// Get the 2D rendering context
            const scoreElement = document.getElementById("score");

            const ROW = 20;
            const COL = COLUMN = 10;
            const SQ = squareSize = 20;
            const VACANT = "WHITE"; // color of an empty square

            function drawSquare(x,y,color){
                ctx.fillStyle = color;
                ctx.fillRect(x*SQ,y*SQ,SQ,SQ);

                ctx.strokeStyle = "BLACK";
                ctx.strokeRect(x*SQ,y*SQ,SQ,SQ);
            }

            // create the board

            let board = [];
            for( r = 0; r <ROW; r++){
                board[r] = [];
                for(c = 0; c < COL; c++){
                    board[r][c] = VACANT;
                }
            }

            // draw the board
            function drawBoard(){
                for( r = 0; r <ROW; r++){
                    for(c = 0; c < COL; c++){
                        drawSquare(c,r,board[r][c]);
                    }
                }
            }

            drawBoard();

            // the Tetris shapes and their colors

            const PIECES = [
                [Z,"red"],
                [S,"green"],
                [T,"yellow"],
                [O,"blue"],
                [L,"purple"],
                [I,"cyan"],
                [J,"orange"]
            ];

            // generate random pieces

            function randomPiece(){
                let r = randomN = Math.floor(Math.random() * PIECES.length) // 0 -> 6
                return new Piece( PIECES[r][0],PIECES[r][1]);
            }

            let p = randomPiece();

            // The Object Piece

            function Piece(tetromino,color){
                this.tetromino = tetromino;
                this.color = color;
                
                this.tetrominoN = 0; // we start from the first pattern
                this.activeTetromino = this.tetromino[this.tetrominoN];
                
                // we need to control the pieces
                this.x = 3;
                this.y = -1;
            }

            // fill function

            Piece.prototype.fill = function(color){
                for( r = 0; r < this.activeTetromino.length; r++){
                    for(c = 0; c < this.activeTetromino.length; c++){
                        // we draw only occupied squares
                        if( this.activeTetromino[r][c]){
                            drawSquare(this.x + c,this.y + r, color);
                        }
                    }
                }
            }

            // draw a piece to the board

            Piece.prototype.draw = function(){
                this.fill(this.color);
            }

            // undraw a piece


            Piece.prototype.unDraw = function(){
                this.fill(VACANT);
            }

            // move Down the piece

            Piece.prototype.moveDown = function(){
                if(!this.collision(0,1,this.activeTetromino)){
                    this.unDraw();
                    this.y++;
                    this.draw();
                }else{
                    // we lock the piece and generate a new one
                    this.lock();
                    p = randomPiece();
                }
                
            }

            // move Right the piece
            Piece.prototype.moveRight = function(){
                if(!this.collision(1,0,this.activeTetromino)){
                    this.unDraw();
                    this.x++;
                    this.draw();
                }
            }

            // move Left the piece
            Piece.prototype.moveLeft = function(){
                if(!this.collision(-1,0,this.activeTetromino)){
                    this.unDraw();
                    this.x--;
                    this.draw();
                }
            }

            // rotate the piece
            Piece.prototype.rotate = function(){
                let nextPattern = this.tetromino[(this.tetrominoN + 1)%this.tetromino.length];
                let kick = 0;
                
                if(this.collision(0,0,nextPattern)){
                    if(this.x > COL/2){
                        // it's the right wall
                        kick = -1; // we need to move the piece to the left
                    }else{
                        // it's the left wall
                        kick = 1; // we need to move the piece to the right
                    }
                }
                
                if(!this.collision(kick,0,nextPattern)){
                    this.unDraw();
                    this.x += kick;
                    this.tetrominoN = (this.tetrominoN + 1)%this.tetromino.length; // (0+1)%4 => 1
                    this.activeTetromino = this.tetromino[this.tetrominoN];
                    this.draw();
                }
            }

            let score = 0;

            Piece.prototype.lock = function(){
                for( r = 0; r < this.activeTetromino.length; r++){
                    for(c = 0; c < this.activeTetromino.length; c++){
                        // we skip the vacant squares
                        if( !this.activeTetromino[r][c]){
                            continue;
                        }
                        // pieces to lock on top = game over
                        if(this.y + r < 0){
                            Swal.fire({
                                title: "Game Over",
                                text: "You can play again.",
                                icon: "error",
                                confirmButtonText: "Restart"
                            }).then((result) => {
                                if (result.isConfirmed) {
                                    resetGame(); // Call resetGame function to restart the game
                                }
                            });
                            // stop request animation frame
                            gameOver = true;
                            break;
                        }
                        // we lock the piece
                        board[this.y+r][this.x+c] = this.color;
                    }
                }
                // remove full rows
                for(r = 0; r < ROW; r++){
                    let isRowFull = true;
                    for( c = 0; c < COL; c++){
                        isRowFull = isRowFull && (board[r][c] != VACANT);
                    }
                    if(isRowFull){
                        // if the row is full
                        // we move down all the rows above it
                        for( y = r; y > 1; y--){
                            for( c = 0; c < COL; c++){
                                board[y][c] = board[y-1][c];
                            }
                        }
                        // the top row board[0][..] has no row above it
                        for( c = 0; c < COL; c++){
                            board[0][c] = VACANT;
                        }
                        // increment the score
                        score += 10;
                    }
                }
                // update the board
                drawBoard();
                
                // update the score
                scoreElement.innerHTML = score;
            }

            // collision fucntion

            Piece.prototype.collision = function(x,y,piece){
                for( r = 0; r < piece.length; r++){
                    for(c = 0; c < piece.length; c++){
                        // if the square is empty, we skip it
                        if(!piece[r][c]){
                            continue;
                        }
                        // coordinates of the piece after movement
                        let newX = this.x + c + x;
                        let newY = this.y + r + y;
                        
                        // conditions
                        if(newX < 0 || newX >= COL || newY >= ROW){
                            return true;
                        }
                        // skip newY < 0; board[-1] will crush our game
                        if(newY < 0){
                            continue;
                        }
                        // check if there is a locked piece alrady in place
                        if( board[newY][newX] != VACANT){
                            return true;
                        }
                    }
                }
                return false;
            }

            // CONTROL the piece

            document.addEventListener("keydown",CONTROL);

            function CONTROL(event){
                if(event.keyCode == 37){
                    p.moveLeft();
                    dropStart = Date.now();
                }else if(event.keyCode == 38){
                    p.rotate();
                    dropStart = Date.now();
                }else if(event.keyCode == 39){
                    p.moveRight();
                    dropStart = Date.now();
                }else if(event.keyCode == 40){
                    p.moveDown();
                }
            }

            let isPaused = false;

            // Function to start or pause the game
            function startPauseGame() {
                if (isPaused) {
                    isPaused = false;
                    drop(); // Resume the game loop
                } else {
                    isPaused = true;
                }
            }

            document.getElementById("start-pause").addEventListener("click", startPauseGame);

            // drop the piece every 1sec
            let dropStart = Date.now();
            let gameOver = false;

            function drop() {
                if (!isPaused) {
                    let now = Date.now();
                    let delta = now - dropStart;
                    if (delta > 1000) {
                        p.moveDown();
                        dropStart = Date.now();
                    }
                    if (!gameOver) {
                        requestAnimationFrame(drop);
                    }
                } else {
                    Swal.fire({
                        title: "Game has been paused.",
                        text: "Click the Start/Pause button to restart the game again!",
                        icon: "information",
                        confirmButtonText: "OK"
                    })
                }
            }

            drop(); // Start the game initially

            // Function to reset the game
            function resetGame() {
                // Clear the board
                for (let r = 0; r < ROW; r++) {
                    for (let c = 0; c < COL; c++) {
                        board[r][c] = VACANT;
                    }
                }

                // Reset score
                score = 0;
                scoreElement.innerHTML = score;

                // Generate a new random piece
                p = randomPiece();

                // Reset game over flag
                gameOver = false;

                // Resume the drop loop
                isPaused = false;
                drop();
            }

            Piece.prototype.lock = function(){
                for( r = 0; r < this.activeTetromino.length; r++){
                    for(c = 0; c < this.activeTetromino.length; c++){
                        // we skip the vacant squares
                        if( !this.activeTetromino[r][c]){
                            continue;
                        }
                        // pieces to lock on top = game over
                        if(this.y + r < 0){
                            Swal.fire({
                                title: "Game Over",
                                text: "You can play again?",
                                icon: "error",
                                confirmButtonText: "Restart"
                            }).then((result) => {
                                if (result.isConfirmed) {
                                    resetGame(); // Call resetGame function to restart the game
                                }
                            });
                            // stop request animation frame
                            gameOver = true;
                        }
                        // we lock the piece
                        board[this.y+r][this.x+c] = this.color;
                    }
                }
                // remove full rows
                for(r = 0; r < ROW; r++){
                    let isRowFull = true;
                    for( c = 0; c < COL; c++){
                        isRowFull = isRowFull && (board[r][c] != VACANT);
                    }
                    if(isRowFull){
                        // if the row is full
                        // we move down all the rows above it
                        for( y = r; y > 1; y--){
                            for( c = 0; c < COL; c++){
                                board[y][c] = board[y-1][c];
                            }
                        }
                        // the top row board[0][..] has no row above it
                        for( c = 0; c < COL; c++){
                            board[0][c] = VACANT;
                        }
                        // increment the score
                        score += 10;
                    }
                }
                // update the board
                drawBoard();
                
                // update the score
                scoreElement.innerHTML = score;
            }


            // Variables to track touch events
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            // Function to handle touch start event
            function handleTouchStart(event) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }

            // Function to handle touch end event
            function handleTouchEnd(event) {
                touchEndX = event.changedTouches[0].clientX;
                touchEndY = event.changedTouches[0].clientY;

                // Calculate the difference in coordinates
                let deltaX = touchEndX - touchStartX;
                let deltaY = touchEndY - touchStartY;

                // Determine the direction based on swipe gesture
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Horizontal swipe detected
                    if (deltaX > 0) {
                        // Swipe towards the right
                        p.moveRight();
                    } else {
                        // Swipe towards the left
                        p.moveLeft();
                    }
                } else {
                    // Vertical swipe detected
                    if (deltaY > 0) {
                        // Swipe downwards
                        p.moveDown();
                    } else {
                        // Swipe upwards (optional action, e.g., rotate)
                        p.rotate();
                    }
                }
            }

            // adding event listeners for touch events
            document.addEventListener('touchstart', handleTouchStart, false);
            document.addEventListener('touchend', handleTouchEnd, false);


            // adding event listeners to control buttons
            document.getElementById("move-left").addEventListener("click", function() {
                p.moveLeft();
                dropStart = Date.now();
            });

            document.getElementById("move-right").addEventListener("click", function() {
                p.moveRight();
                dropStart = Date.now();
            });

            document.getElementById("rotate").addEventListener("click", function() {
                p.rotate();
                dropStart = Date.now();
            });

            document.getElementById("move-down").addEventListener("click", function() {
                p.moveDown();
            });

        </script>
    </div>
</body>
</html>